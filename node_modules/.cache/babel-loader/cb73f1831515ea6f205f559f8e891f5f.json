{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = require('assert');\nvar ethjsUtil = require('ethjs-util');\nvar secp256k1 = require('./secp256k1v3-adapter');\nvar BN = require(\"bn.js\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  }\n  // Only take the lower 160bits of the hash\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n  pubKey = bytes_1.toBuffer(pubKey);\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n  assert(pubKey.length === 64);\n  // Only take the lower 160bits of the hash\n  return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n  return publicKey;\n};","map":{"version":3,"names":["assert","require","ethjsUtil","secp256k1","BN","bytes_1","hash_1","exports","zeroAddress","addressLength","addr","zeros","bufferToHex","isValidAddress","address","test","isZeroAddress","zeroAddr","addHexPrefix","toChecksumAddress","eip1191ChainId","stripHexPrefix","toLowerCase","prefix","undefined","toString","hash","keccak","ret","i","length","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","from","nonce","toBuffer","nonceBN","isZero","rlphash","slice","Buffer","toArray","generateAddress2","salt","initCode","fromBuf","saltBuf","initCodeBuf","keccak256","concat","isPrecompiled","a","unpad","isValidPrivate","privateKey","privateKeyVerify","isValidPublic","publicKey","sanitize","publicKeyVerify","pubToAddress","pubKey","publicKeyConvert","publicToAddress","privateToAddress","privateToPublic","publicKeyCreate","importPublic"],"sources":["../src/account.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}