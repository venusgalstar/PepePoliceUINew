{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\nvar der = require('./secp256k1v3-lib/der');\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nexports.privateKeyVerify = function (privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nexports.privateKeyExport = function (privateKey, compressed) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyImport = function (privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyNegate = function (privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.privateKeyModInverse = function (privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCreate = function (privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyConvert = function (publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.publicKeyVerify = function (publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureNormalize = function (signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureExport = function (signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImport = function (signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nexports.signatureImportLax = function (signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nexports.sign = function (message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n  var signOptions = undefined;\n  if (options) {\n    signOptions = {};\n    if (options.data === null) {\n      // validate option.data length\n      throw new TypeError('options.data should be a Buffer');\n    }\n    if (options.data) {\n      if (options.data.length != 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n      signOptions.data = new Uint8Array(options.data);\n    }\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n    if (options.noncefn) {\n      // convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n        return new Uint8Array(buffer);\n      };\n    }\n  }\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nexports.verify = function (message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nexports.recover = function (message, signature, recid, compressed) {\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nexports.ecdh = function (publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};","map":{"version":3,"names":["secp256k1","require","secp256k1v3","der","exports","privateKeyVerify","privateKey","length","Uint8Array","from","privateKeyExport","compressed","RangeError","publicKey","privateKeyImport","Error","privateKeyNegate","Buffer","privateKeyModInverse","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeyCombine","publicKeys","keys","forEach","push","signatureNormalize","signature","signatureExport","signatureImport","signatureImportLax","sigObj","sign","message","options","TypeError","signOptions","undefined","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","verify","ecdsaVerify","recover","ecdsaRecover","ecdh","ecdhUnsafe"],"sources":["../src/secp256k1v3-adapter.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}